# 垃圾回收

[toc]

##  垃圾回收的区域

- 垃圾收集主要是针对堆和方法区进行。
- 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

## 判断对象是否有引用的方法

- 可达性分析法
  - 通过选取一些根对象作为起始点，开始向下搜索，搜索不到的对象就认为是没有被引用，是可以被回收的。
- 引用计数算法
  - 存在循环引用，引用计数器永远不为0的

## 为什么要学习垃圾回收？

- 排查内存溢出
- 排查内存内泄漏
- 性能调优，排查并发瓶颈

## 垃圾回收的方法

- System.gc() 
- Runtime.getRuntime().gc()

## 垃圾回收的步骤

- 找到垃圾
  
  - 可达性分析法
- 收集垃圾
  
  三种垃圾收集算法：
  - 标志-清除算法 Mark-Sweep 算法。这个算法分为两阶段，先标记处所有需要回收的对象，然后统一清除。这个方法会产生大量的内存碎片，性能很低。
  - 复制算法 Coping。将内存均分为两块，每次只使用一块进行内存分配。当被使用块被标记后，将剩余活着的对象直接复制到另一块，原先的一块清空。这个方法简单粗暴，但是可利用内存只有一半。
  - 标记-整理算法 Mark-Conpact算法。和标志-清除算法大致相同，区别是在清除结束了后会把对象往一侧移动，挤压内存碎片留下的空隙。
- 回收

## 四种引用

- 强：代表什么时候都不会被回收的引用
- 软：只要内存不够就会被回收的引用
- 弱：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
- 虚：随时可以能会被回收的引用