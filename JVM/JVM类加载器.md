# JVM类加载器和执行引擎

[TOC]

## 类加载器

类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字。

### 三种 ClassLoader

![](http://upload-images.jianshu.io/upload_images/634730-ffd9553bc18ea213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  

- Bootstrap ClassLoader：

  主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等

- Extention ClassLoader

  扩展的类加载器，加载目录%JRE_HOME%\lib\ext

- Appclass Loader

### 双亲委托模型

Java中ClassLoader的加载采用了双亲委托机制，采用双亲委托机制加载类的时候采用如下的几个步骤：

当一个类加载器收到类加载请求:

1.  当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。

2.  当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp ClassLoader.

3.  当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。

### 为什么使用双亲委托模型

确保类的全局唯一性。

如果你自己写的一个类与核心类库中的类重名，会发现这个类可以被正常编译，但永远无法被加载运行。因为你写的这个类不会被应用类加载器加载，而是被委托到顶层，被启动类加载器在核心类库中找到了。如果没有双亲委托机制来确保类的全局唯一性，谁都可以编写一个java.lang.Object类放在classpath下，那应用程序就乱套了。

从安全的角度讲，通过双亲委托机制，Java虚拟机总是先从最可信的Java核心API查找类型，可以防止不可信的类假扮被信任的类对系统造成危害。

### 类的加载过程

- 加载：获取.class文件的二进制流将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区中。
在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的
  
- 验证：这一阶段的目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 准备：为类变量分配变量，并设置初始值

- 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。为什么要用符号引用呢？这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量他们的引用地址在哪里，所以只能用符号引用来表示。

- 初始化：给static变量赋值以及执行静态代码块。

- 使用

- 卸载

JVM规范定义了上面的几个任务，不过它允许具体执行的时候能够有些灵活的变动。

### Java程序初始化顺序

1、父类的静态变量
 2、父类的静态代码块
 3、子类的静态变量
 4、子类的静态代码块
 5、父类的非静态变量
 6、父类的非静态代码块
 7、父类的构造方法
 8、子类的非静态变量
 9、子类的非静态代码块
 10、子类的构造方法