# Mysql的锁机制

[TOC]

## 首先

mysql有一个autocommit参数，默认是on，他的作用是每一条单独的查询都是一个事务，并且自动开始，自动提交（如果使用select for update，需要手动调用 start transaction），所以事务隔离级别和锁机制即使你不显式调用start transaction，这种机制在单独的一条查询语句中也是适用的，分析锁的运作的时候一定要注意这一点。

隔离级别只是保证事务不会互相读取中间数据，不能解决并发性问题。


## mysql对默认对什么操作加锁？

mysql InnoDB引擎默认的修改数据语句，**update,delete,insert** 都会自动给涉及到的数据加上**排他锁**，select语句默认不会加任何锁类型

## 为什么会有隔离级别？

脏读、不可重复读、幻读其实都是数据库 **读**一致性的问题，必须有数据库的隔离机制来解决。

## 各个隔离级别的区别是什么？

我知道的隔离级别有四种：

Read uncommitted：一个事务可以读取另一个事务未提交的数据， 

问题：脏读，一个事务读到另一个事务未提交的数据

Read committed：事务只能读取到已经提交的数据

问题：不可重复度：一个事务范围内两个相同的查询却返回了不同数据，由于另一个事务更新了数据。

Repeatable read：读取数据时的时候，不允许其他事务更新该数据，解决的是update

问题：可重复读无法避免幻读：一个事务查询返回了不同的数据，由于另一个事务插入了数据

Serializable：所有的事务都串行化执行


隔离级别的实现：

1、利用MVCC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题

2、利用Gap Locks和Next-Key可以阻止其它事务在锁定区间内插入数据，因此解决了幻读问题


**三个等级解决的是脏读、不可重复读、幻读的问题，不可重复度对应update，序列化对应的是insert**


## 为什么会有共享锁和排它锁？

对于select 语句，innodb不会加任何锁，也就是可以多个并发去进行select的操作，不会有任何的锁冲突，因为根本没有锁。
对于insert，update，delete操作，innodb会自动给涉及到的数据加排他锁，只有查询select需要我们手动设置排他锁。

共享锁(读锁): SELECT ... LOCK IN SHARE MODE，则其他事务只能加s锁，不能加x锁，加锁后update会报错

排它锁（写锁）: SELECT ... FOR UPDATE UPDATE，任何事务都不能对数据加锁，其他事务一直等到事务提交再加锁update，可以正常读取数据。

悲观锁包括共享锁和排它锁，

## 什么时候使用行锁、表锁(innodb)

数据库实现事务隔离的方法可分为两种，一种是在读取数据钱对数据加锁，组织其他事务更该数据。

粒度越小实现的成本越高，innodb行锁是通过给索引加锁来实现的，这就意味着，只有通过索引条件检索数据，innodb才能使用行级锁，否则，innodb降使用表锁。
悲观锁包括共享锁和排它锁。

## 乐观锁和悲观锁的区别

用乐观锁的前提是对数据冲突持乐观态度，选取一个字段作为标记，在update的时候加一个where条件判断字段是否被更改

悲观锁则是在sql加一个for update

## 数据库死锁的原因：

若干事务相互等待对方释放封锁，就陷入了无限期等待状态，系统进入死锁。

## MVCC 并发版本控制

多版本并发控制解决写操作阻塞读操作的并发问题
MVCC可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作
MVCC的实现大都都实现了非阻塞的读操作，写操作也只锁定必要的行。

**如何实现**

innodb的mvcc通过两个隐藏列实现，一个保存了行的创建时事务版本号（事务id），一个保存删除时的事务版本号（事务id）

查询时，只会读取版本号小于或等于当前版本号的数据行

插入时，创建版本号会更新为当前事务的版本号

删除时，对应行的删除版本号会更新为当前的事务版本号，innodb后台会有一个线程清理删除版本号小于当前系统版本号的行

更新时，就是执行删除和插入操作

